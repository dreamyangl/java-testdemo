/**
 * 1. 合并时间区间（建议时间复杂度 O(n) ）
 * 给定⼀个按开始时间从⼩到⼤排序的时间区间集合，请将重叠的区间合并。时
 * 间区间集合⽤⼀个⼆维数组表示，⼆维数组的每⼀⾏表示⼀个时间区间（闭区
 * 间），其中 0 位置元素表示时间区间开始，1 位置元素表示时间区间结束。
 * 例 1：输⼊：[ [1, 3], [2, 6], [8, 10], [15, 18] ]
 *  返回： [ [1, 6], [8, 10], [15, 18]]
 *  解释：时间区间 [1, 3] 和 [2, 6] 有部分重叠，合并之后为 [1, 6]
 * 例 2：输⼊：[[1, 4], [4, 5]]
 *  返回：[[1, 5]]
 *  解释：时间区间[1，4] 和 [4，5]重叠了⼀个时间点，合并之后为 [1，5]
 * 需要实现的⽅法原型：int[][] merge(int[][] intervals)
 *
 * 2. 缩写校验（建议时间复杂度 O(n) ）
 * 给定⼀个⾮空字符串 s 和⼀个缩写 abbr，请校验它们是否匹配。
 * 假设字符串中只包含⼩写字⺟，缩写中只包含⼩写字⺟和数字。缩写中的数字
 * 表示其缩略的字符数；连续多位数字表示⼀个多位数。
 * 例如，字符串 “word” 的缩写有且仅有以下这些：[“word", "1ord", "w1rd",
 * "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d",
 * "w3", “4"]。
 * 例 1：输⼊：s = “internationalization"，abbr = "i12iz4n"
 *  返回：true
 *  解释：abbr 中的 12 表示有⼗⼆个字符被缩略了。
 * 例 2：输⼊：s = “apple"，abbr = “a2e"
 *  返回：false
 * 需要实现的⽅法原型：boolean valid(String word, String abbr)
 *
 * 3. 聪明的⼩偷（建议时间复杂度 O(n) ）
 * 有⼀个职业⼩偷，打算盗窃某个圆形⼴场上的沿街商铺。每间商铺内都存放了
 * ⼀定⾦额的现⾦。所有商铺围绕⼴场形成了⼀个环，即第⼀间商铺与最后⼀间
 * 商铺也是相邻的。同时，每两间相邻的商铺之间都连接了⼀套报警系统（包括
 * 第⼀间和最后⼀间商铺之间）。如果两间相邻的商铺在同⼀个晚上同时被偷，
 * 就会⾃动触发报警系统。
 * 给定⼀个⾮负整数数组，表示每间商铺中存放的⾦额，请问，在不触发报警系
 * 统的前提下，这位职业⼩偷⼀个晚上总共最多能偷到多少⾦额？
 * 例1：输⼊： [2,3,2]
 *  返回： 3
 *  解释：因为房间1（⾦额=2）和 房间3（⾦额=2）也是相邻的，所以不能
 * 同时偷这两个，那就只能偷⾦额最⼤的房间 2（⾦额=3）
 * 例 2：输⼊：[1,2,3,1]
 *  返回：4
 *  解释: 从房间1 (⾦额=1) 和 房间3 (⾦额=3)可以偷取最⼤的⾦额 1+3=4
 * 注意：数组中所有元素相加不会超过 20 亿
 * 需要实现的⽅法原型： int steal(int[] nums)
 */